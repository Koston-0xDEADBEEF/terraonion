package neo

import "encoding/binary"

func pcm2Decrypt(b []byte, value int) []byte {
	rom := make([]uint16, len(b)/2)
	for i := range rom {
		rom[i] = binary.LittleEndian.Uint16(b[i*2 : (i+1)*2])
	}

	buf := make([]uint16, value/2)

	for i := 0; i < len(rom); i += value / 2 {
		copy(buf, rom[i:])
		for j := 0; j < value/2; j++ {
			rom[i+j] = buf[j^(value/4)]
		}
	}

	return uint16SliceToBytes(rom)
}

func pcm2Swap(b []byte, value int) []byte {
	addrs := [7][2]uint32{
		{0x000000, 0xa5000},
		{0xffce20, 0x01000},
		{0xfe2cf6, 0x4e001},
		{0xffac28, 0xc2000},
		{0xfeb2c0, 0x0a000},
		{0xff14ea, 0xa7001},
		{0xffb440, 0x02000},
	}
	xordata := [7][8]byte{
		{0xf9, 0xe0, 0x5d, 0xf3, 0xea, 0x92, 0xbe, 0xef},
		{0xc4, 0x83, 0xa8, 0x5f, 0x21, 0x27, 0x64, 0xaf},
		{0xc3, 0xfd, 0x81, 0xac, 0x6d, 0xe7, 0xbf, 0x9e},
		{0xc3, 0xfd, 0x81, 0xac, 0x6d, 0xe7, 0xbf, 0x9e},
		{0xcb, 0x29, 0x7d, 0x43, 0xd2, 0x3a, 0xc2, 0xb4},
		{0x4b, 0xa4, 0x63, 0x46, 0xf0, 0x91, 0xea, 0x62},
		{0x4b, 0xa4, 0x63, 0x46, 0xf0, 0x91, 0xea, 0x62},
	}

	rom := make([]byte, 0x1000000)

	for i := 0; i < 0x1000000; i++ {
		j := bitswapInt(i, 23, 22, 21, 20, 19, 18, 17, 0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 16)
		j ^= int(addrs[value][1])
		d := (i + int(addrs[value][0])) & 0xffffff
		rom[j] = b[d] ^ xordata[value][j&0x07]
	}

	return rom
}
